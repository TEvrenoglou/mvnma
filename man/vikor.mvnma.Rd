% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/VIKOR.R
\name{vikor.mvnma}
\alias{vikor.mvnma}
\title{Rank treatments across all outcomes using the VIKOR multi-criteria decision analysis method.}
\usage{
vikor.mvnma(x, weights = NULL, v = 0.5, pos.sol = NULL, neg.sol = NULL)
}
\arguments{
\item{x}{An object of class \code{\link{mvrank}}.}

\item{weights}{Outcome weights. The weights should always sum to 1. If not then they are standardized. If NULL, the function will assume equal outcome weights.}

\item{v}{A scalar from 0 to 1 interpreted as the weight of the decision making process. Following guidance from the multi-criteria decison analysis field it is set to 0.5.}

\item{pos.sol}{A vector of values containing the positive ideal solution for each outcome. If NULL it is always set to 1 for each outcome (see details).}

\item{neg.sol}{A vector of values containing the negative ideal solution for each outcome. If NULL it is always set to 0 for each outcome (see details).}
}
\value{
The function returns a 'vikor.mvnma' object. This consists of three ranking lists which are the following:
\begin{itemize}
\item A ranking list Q referring to the ranking when balancing both each treatment's overall and worst performance. This is the main ranking list of the method. 
\item A ranking list S referring to the ranking in terms of each treatment's overall performance.
\item A ranking list R referring to the ranking in terms of penalizing each treatment's worst performance.
\end{itemize}
}
\description{
This function employs the VIKOR method to analyze all outcome-specific ranking lists. It provides both an amalgamated ranking list and guidance on which treatments correspond to the best compromise solutions.
}
\details{
The function \code{\link{vikor.mvnma}} takes a single mandatory argument which is an object of class mvrank. It then uses the multi-criteria decision analysis method VIKOR to
produce an amalgamated ranking list across all outcomes. The final ranking list is calculated based on the common across outcomes treatments. Treatments not existing across all
outcomes are excluded internally. 

Using the argument 'weights' the users can specify the weight that each outcome should have in the decision making process. For each outcome this argument should have a value from 0 to 1 while the sum of all outcome weights should be 1.
If the sum of all weights is not 1, then these are internally standardize to achieve this. The standardized weight values are returned as a message to the user. Finally, if NULL then equal weights are assumed across all outcomes.

The argument 'v' specifies the weight of the decision making process. The VIKOR method is a compromise programming approach that aims to balance between each treatments overall and worst performance across all outcomes. The balance between 
these two criteria is achieved using the parameter 'v' which takes values from 0 to 1. Values close to 1 will give more weight to the treatment's overall performance while values close to 0 will give more weight to penalize the treatment's worst performance.
The most common choice of 'v' is typically 0.5 (default also here), thereby allowing for a balanced decision making between treatment's overall and worst performance.

The arguments 'pos.sol' and 'neg.sol' represent the positive and negative ideal solutions to be targeted. When synthesizing either SUCRA or pBV outputs then in both cases the positive ideal solution is by definition 1 (the ideal treatment has a SUCRA or a pBV of 1). 
Similarly the ideal negative solution is by definition 0. Therefore, if NULL 'pos.sol=1' and 'neg.sol=0'. Howeever, if users aim at differennt SUCRA or pBV values for each outcome they can still specify 'pos.sol' or 'neg.sol' in terms of a vector (one for each argument)
with length equal to the number of outcomes and values from 0 to 1.
}
\examples{
library(netmeta)

data("Linde2015")

# use 'pairwise' to obtain contrast based data for each one of the five available outcomes 

  # Early response

p1 <- pairwise(treat = list(treatment1, treatment2, treatment3),
             event = list(resp1, resp2, resp3), 
              n = list(n1, n2, n3),
              studlab = id,
              data = dat.linde2015,
              sm = "OR")


# Early remissions

p2 <- pairwise(treat = list(treatment1, treatment2, treatment3),
              event = list(remi1, remi2, remi3),
              n = list(n1, n2, n3),
              studlab = id,
              data = dat.linde2015,
              sm = "OR")

# Perform analysis in terms of the Efficacy outcomes

p_effic <- list(p1,p2)

# Use 'mvdata()' to transform the data in suitable JAGS format

data_effic <- mvdata(p_effic)

# Define outcome labels

outlab <- c("Early_Response","Early_Remission")
            
# Fit the model combining only the two efficacy outcomes

mvmodel_effic <- mvnma(data = data_effic,
                reference.group = "Placebo",
                outlab = outlab,
                n.iter = 1000,
                n.burnin = 100)
                
# Extract treatment effect estimates and heterogeneity for Early_Response 

mvmodel_effic$Early_Response$basic_estimates

# Get all estimates                 

league.effic <- league(mvmodel_effic)
# Rank treatments using sucra

ranks_sucra <- mvrank(mvmodel_effic,small.values = c("undesirable","undesirable"), method = "sucra")
                    
ranks_sucra

# Get the best compromise solution across all Efficacy outcomes

vikor.mvnma(ranks_sucra)

interpret.vikor(vikor.mvnma(ranks_sucra))

# Add larger weight for Response than Remission

vikor.mvnma(ranks_sucra,weights=c(0.6,0.3))

interpret.vikor(vikor.mvnma(ranks_sucra,weights=c(0.6,0.3)))


}
